### SERVER Setup
- mkdir zoom && cd zoom 
- npm init -y 
- touch README.md
- npm i nodemon -D
- babel.config.json && nodemon.json 파일 생성 
- src폴더 생성 및 server.js 파일 생성 
- git init  
- npm i @babel/core @babel/cli @babel/node -D
- touch .gitignore (node_modules추가)
- nodemon.json => "exec": "babel-node src/server.js"
- babel.config.json =>  "presets" : ["@babel/preset-env"]
- npm i @babel/preset-env -D
- package.json 스크립트 추가 => "scripts": {"dev": "nodemon"},
- npm i express pug  

### FRONT Setup
- app.set("view engine", "pug");
- app.set("views", __dirname + "/src/views");
- app.get("/", (req, res) => res.render("home"));
- app.use("/public", express.static(__dirname + "/public"));
- MVP CSS import
- <link rel="stylesheet" href="https://unpkg.com/mvp.css">
- server.js는 Backend에서 구동될거고 app.js는 FrontEnd에서 구동된다. 
- express.static은 유저에게 /public으로 가면 public폴더를 볼수 있도록 허용하는것이다. 

### Websocket
- HTTP vs WebSocket 둘다 모두 프로토콜이다. 
- 인터넷 전체가 http를 기반으로 만들어져있다.
- http는 stateless이다. 유저와 서버사이에 아무런 연결이 없다. 서버는 유저가 누구인지 잊어버린다.
- webSocket연결이 일어날땐 마치 악수처럼 작동한다. 
- 브라우저가 서버로 webSocket request를 보내면, 서버가 받거나 거절한다. 
- 브라우저와 서버가 서로 커뮤니케이션하는 터널이다. (bi-directional connection 양방향 연결)
- 서버는 브라우저에게 어떤때나 메세지를 보낼수 있다.   
- 브라우저에는 내장된 webSocket API가 있다. 
- WebSocket은 어떤 프로그래밍 언어에 국한되어 있지않다. 그저 protocol일뿐 
- real-time으로 소통하는 2개의 서버 사이에서도 작동한다. 
- protocol은 어떤 사람들이 어딘가에 있는 방에서 만나고 어떻게 일들이 진행될지를 결정한다. 어떻게 모든것이 돌아가야할지에 대한 규칙을 만든다. 그런 다음, 프로그래머는 이 규칙을 가지고 이 규칙을 따르는 코드를 만들어서 실행한다. 
- ws는 webSocket protocol을 실행하는 package이다. 
- 채팅방은 ws에 포함되어 있지 않다. 채팅방이 webSocket protocol의 일부분이 아니기 때문이다. 
- 채팅방을 위해서는 ws로 만든 framework를 사용하면 된다. 
- ws는 webSocket의 core(핵심)이다. (완전 기초가 되는 밑바탕)
- npm i ws
- WebSocket도 event가 있고, event가 발동될때 사용할 function을 만들면 된다. 
- webSocket은 listen할 특정한 event명이 있다. 
- socket은 연결된 어떤 사람이다. 연결된 브라우저와의 contact라인이다. 
- socket을 이용하면 메세지를 주고 받을수 있다.
- wss.on("connection")에서 on 메소드는 event가 발동하는걸 기다린다. 여기서 event는 connection이다. 
- on 메소드는 socket에서 백엔드에 연결된 사람의 정보를 제공해준다. 
- webSocket은 브라우저와 서버사이의 연결이다. 
- server.js의 socket은 연결된 브라우저를 뜻한다. 
- app.js의 socket은 서버로의 연결을 뜻한다. 
- socket.send()에서 JSON형태로 보내게 되면 서버에서는 stringify된 JSON을 JSON.parse로 받아야한다.
- 백엔드로 javascript object를 보내면 좋지 않다. 연결하고 싶은 백엔드와 프런트가 javascript서버가 아닐수도 있기 때문이다. Java, Go서버일수도 있다. 

### Socket.IO
- socket.IO는 실시간, 양방향, event 기반의 통신을 가능하게한다.
- Socket.IO는 framework인데 Websocket보다 탄력성이 뛰어나다.
- Socket.IO는 webSocket의 부가기능이 아니다. 
- 만약 webSocket 이용이 불가능하면, Socket.IO는 다른 방법을 이용해서 계속 작동한다.
- 만약 webSocket 연결을 할수 없는 경우 HTTP long polling을 사용한다.
- Socket.IO는 우리에게 신뢰성을 준다. 즉, 브라우저가 webSocket 지원을 안하거나 webSocket 연결에 문제가 있거나 회사에서 webSocket 사용이 안되는 경우나 Firewall 혹은 proxy가 있거나 등등 어떤 경우에든 Socket.IO는 실시간 기능을 제공해준다. 
- Socket.IO는 프런트와 백엔드 간 실시간 통신을 가능하게 해주는 프레임워크 또는 라이브러리이다. 
- npm i socket.io
- 브라우저에도 Socket.IO설치를 해야한다. 브라우저가 주는 webSocket은 Socket.IO와 호환이 되지 않고 Socket.IO가 더 많은 기능을 주기 때문이다. 
- script(src="/socket.io/socket.io.js") => HTML에 해당 script를 넣으면 Socket.IO설치가 된다. 
- const socket = io();에서 io function은 알아서 socket.io를 실행하고 있는 서버를 찾는다. 
- socket.IO에는 이미 room의 기능이 있다. 
- socket.IO는 특정한 event를 emit할수 있다.(어떤 이름이든 상관없다)
- 또한 object를 전송할수 있다.
- <webSocket보다 개선된점> 
- 1. 어떤 event든지 전송할수있다. webSocket에서는 event이름이 message만 가능 (이벤트의 이름을 맘대로 정할수있다)
- 2. javascript object를 전송할수있다. webSocket에서는 JSON.stringify해야함
- 3. socket.emit의 마지막 argument로 callback function을 넣을수 있다.
- socket.emit()의 첫번째 인자는 event이름, 두번째 인자는 보내고 싶은 payload, 마지막 인자는 서버에서 호출하는 function을 넣을수있다. 
- 마지막 인자에 들어가는 function은 서버에서 호출하고 프런트에서 실행한다. 
- 4. webSocket에서는 text만 전송할수 있었지만 socket.IO에서는 어떤것이든 보낼수 있다.(무한정 argument로 보낼수있다)
- chat Room을 만들기 위해서는 socket.join()에 room의 이름을 입력하면된다. 
- user의 id는 user가 있는 방의 id와 같다.(socket.id)
- socketIO에서 socket은 기본적으로 User와 서버사이에 private room이 있다.